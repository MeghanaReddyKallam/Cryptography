import hashlib
import time
import string
import sys

'''Functions'''
#Function that compares hash values and prints desired output if a match is found
def FindMatch(guess, guess_hash, num_guess):
    if guess_hash == password_hash: #hash strings match
        end_time = time.monotonic()
        tot_time = end_time - start_time
        print(f'Cracked Password is: {guess}')
        print(f'({num_guess} passwords attempted in {tot_time} seconds)')
        return(True)
    else: #hash strings do not match
        return(False)

'''All conceivable combinations of guesses are generated by these functions.
Each function calls the function below it. The only function that actually
examines guesses against the password is BruteLen1().We can manually write
functions for each scenario because we know the password length is less than or equal to 6.'''

def BruteLen1(x):
    global num_guess, match
    for i in range(len(strngs)):
        num_guess += 1
        guess = x + strngs[i]
        guess_hash = str(hashlib.md5(str.encode(guess)).hexdigest())
        match = FindMatch(guess, guess_hash, num_guess)
        if match:
            break
    return match

def BruteLen2(x):
    global match
    for i in range(len(strngs)):
        match = BruteLen1(x + strngs[i])
        if match:
            break
    return match

def BruteLen3(x):
    global match
    for i in range(len(strngs)):
        match = BruteLen2(x + strngs[i])
        if match:
            break
    return match

def BruteLen4(x):
    global match
    for i in range(len(strngs)):
        match = BruteLen3(x + strngs[i])
        if match:
            break
    return match

def BruteLen5(x):
    global match
    for i in range(len(strngs)):
        match = BruteLen4(x + strngs[i])
        if match:
            break
    return match

def BruteLen6():
    global match
    for i in range(len(strngs)):
        match = BruteLen5(strngs[i])
        if match:
            break
    return match

'''This function contains all the code for the dictionary option'''
def Dict_crack():
    global start_time
    count = 0 #Initialize guess counter
    while True:
        #enter the file path for the wordlist
        path = input('enter the file path: ') 
        try: #Open and read the file
            password_file = open(path,'r')
            break
        except: #ask again if file not found
           print('File not found')
           continue
    
    start_time = time.monotonic() #Check start time for cracking session
    
    for word in password_file:        
        enc_word = word.strip().encode('utf-8') #utf-8 encoding 
        digest = str(hashlib.md5(enc_word.strip()).hexdigest()) #md5 hash is computed for the word,strip of white spaces,hexadecimal format 
        count += 1 #count is increased for every word check in the file
        if FindMatch(word.strip(), digest, count): #if hash is matched 
            return #End the for loop

    end_time = time.monotonic()
    tot_time = end_time - start_time
    print("Password not in dictionary :(")
    print(f'({count} passwords attempted in {tot_time} seconds)')
    return
    
'''This function contains the code for the brute force method'''
def Bruteforce_crack():
    global strngs, start_time, num_guess
    num_guess = 0 #Initialize guess counter
    match = False #Initialize boolean that will become True when password is cracked
    
    while True:
        #Prompt user for choice
        print("Choose character set for brute force attack from the following options")
        char_set = input("1: [a-z]\n2: [A-Z]\n3: [0-9]\n4: [a-z, A-Z, 0-9]\n5: all non-whitespace characters\n")
        #Set possible characters according to user selection
        if char_set == '1':
            strngs = string.ascii_lowercase
            break
        elif char_set == '2':
            strngs = string.ascii_uppercase
            break
        elif char_set == '3':
            strngs = string.digits
            break
        elif char_set == '4':
            strngs = string.digits + string.ascii_letters
            break
        elif char_set == '5':
            strngs = string.ascii_letters + string.digits + string.punctuation
        else:
            #Error message if user does not choose 1-5
            print("Sorry, invalid option. Please try again")
            continue
        
    
    start_time = time.monotonic() #Check start time for cracking session

    
    if BruteLen1(""):
        return
    if BruteLen2(""):
        return
    if BruteLen3(""):
        return
    if BruteLen4(""):
        return
    if BruteLen5(""):
        return
    if BruteLen6:
        return
        
    #Message to display if no password match is found
    if not match:
        end_time = time.monotonic()
        tot_time = end_time - start_time
        print("Password could not be cracked.")
        print(f'({num_guess} passwords attempted in {tot_time} seconds)')
        return
    
'''Functions'''

'''Main body runs since while loop to allow multiple cracking sessions'''
while True:
    #Give option to close program or run again
    exist = input("Type 'end' to terminate the program, or any other key to continue: ")
    if exist == 'end':
        break

    #Get the hash of the password to be cracked
    password_hash = input("Enter the hash of the password you want to crack:")

    #Ask the user to choose dictionary or brute force option
    while True:
        option = input("Choose which cracking option to use\n1: Dictionary\n2: "
                       "Brute Force\n")
        if option != '1' and option != '2':
            #Error message
            print("Invalid option. Please try again")
            continue
        break

    if option == '1':
        Dict_crack()
    elif option == '2':
        Bruteforce_crack()
